{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///./src/mobileCore/conversionUtils.ts","webpack:///./src/mobileCore/conversionConfig.ts","webpack:///./src/mobileCore/analyzer/analyzerUtils.ts","webpack:///external \"coreUtilsLib\"","webpack:///./src/mobileCore/analyzer/sweepSortAnalyzer.ts","webpack:///./src/mobileLayoutUtils/sortingUtils.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","isMergeVirtualGroup","comp","VIRTUAL_GROUP_TYPES","MERGE","isRescaleVirtualGroup","RESCALE","isVirtualGroup","isDesktopOnlyComponent","component","isTextComponent","isVerticalText","isGraphicComponent","isImageComponent","isGroupComponent","componentType","isColumnsContainerComponent","isMasterPage","isMasterPageChild","id","isDockingAllowed","isFixedPositionAllowed","isFixedPositionElement","shouldConvertFixedPositionToAbsolute","isExistsBeforeMerge","mobileComp","existsBeforeMerge","shouldStretchToScreenWidth","shouldStretchHorizontally","conversionData","components","isSiteSegmentOrPage","extractComponentsFromStructureByType","root","compTypes","children","getChildren","extractedChildrenByType","child","isScreenWidthComponent","translateComps","comps","x","y","layout","reparentComponent","parent","newChild","index","addComponentsTo","container","length","undefined","splice","apply","concat","removeChildrenFrom","componentsToRemove","removeGroup","group","groupParent","groupIndex","reverse","curGroupedComponent","containsComponent","componentMatcher","getHeightAccordingToChildren","enforceShrinkEvenWithNoChildren","lowestChildBottom","reject","reduce","lowest","height","SECTION_MOBILE_MARGIN_Y","COMPONENT_MOBILE_MARGIN_Y","ensureContainerTightlyWrapsChildren","defaultMinHeight","heightByChildren","minHeight","Math","max","isPageComponent","isSiteSegment","type","isMobileOnlyElement","mobileComponent","isModifiedComponent","isContainerComponent","isAllowedToBeInMasterPage","extractMobilePage","desktopPage","mobilePage","cloneDeep","childrenPropertyName","mobileComponents","getComponentByIdFromStructure","componentId","res","unifyGroups","groups","groupOverflowThreshold","j","arr1","arr2","getComponentsByIds","compIds","getParent","getSnugLayout","mostLeft","mostTop","width","rotationInDegrees","getTinyMenuDefaultPosition","MOBILE_WIDTH","TINY_MENU_SIZE","SITE_SEGMENT_PADDING_X","getRangesOverlap","range1","range2","getSortedRangesOverlap","r1","r2","min","getYOverlap","comp1","comp2","getYProjection","getXOverlap","getXProjection","getArea","hasGreaterArea","haveSufficientOverlap","overlapToMinAreaRationThreshold","xOverlap","yOverlap","overlapArea","minCompArea","isEmptyContainer","category","shouldReparentCompToChildOfContainer","getAllCompsInStructure","compStructure","isMobile","filterFunc","queue","innerQueue","push","flatten","remove","keyBy","conversionConfig","MARGIN_BETWEEN_TEXT_AND_NON_TEXT","COMPONENT_MOBILE_MARGIN_X","TEXT_MAX_LENGTH_FOR_RESCALING","MIN_WIDTH_FOR_ENLARGE","DEFAULT_TEXT_HEIGHT","getSign","abs","getComponentSize","dim","getComponentEndCoordinate","axis","similarBy","valuePath","deviationThreshold","v1","v2","areSimilarFragments","fragment1","fragment2","dimension","shouldBreakFragment","compIndex","haveSimilarCoordinates","fragment","firstDistantCompIndex","previousCompEnd","distance","getOrderedComponents","componentsOrder","shouldUseNaturalOrder","rescaleMethod","structuralContainer","sortComponentsByNaturalOrder","childrenIds","indexOf","hasMobileHintsPresets","mobileHints","__WEBPACK_EXTERNAL_MODULE__4__","EVENTS_TYPES","DISTANCE_PARTITIONS_WEIGHTS","refragment","fragments","getNewFragmentIndex","fragmentIndex","newFragmentIndex","distanceToPreviousFragment","strategiesHandlers","singleCompRow","allEvents","partitionAxis","singleCompRowIndex","newFragments","oldFragmentIndex","fragmentsEvents","splitAllEventsByFragments","verticalDivider","dividerFragmentIndex","eventsCoordinates","partition","eventType","map","a","maxStart","minEnd","firstComp","keepIfVerticalDivider","findVerticalDividerFragmentIndex","mirrorPattern","perpAxis","getPerpendicularAxis","sortedFragmentsComps","fragmentEvents","extractCompsFromEvents","isMirrorPattern","fragmentComps","createSingleFragmentPartition","chessPattern","xSortedFragmentsComps","chessSortedComps","isEven","evenCategory","oddCategory","events","uniq","sortedComps","partitionData","insertStable","arr","event","e","coordinate","size","compRef","createEventsQueue","eventsQueue","componentStartPosition","componentEndPosition","componentSize","createFragments","sweepLineEvents","sweepLineStatus","lastFragment","newFragment","divideByDistance","mostDistantFragment","mostDistantFragmentIndex","adjacentFragments","adjacentFragmentsEvents","g","maxCompsDistance","calculateMaxCompsDistance","eventsPartition","vectorIndex","closestPoint","vector","lastAddedEvent","extractPartitionAxisVectors","eventIndex","maxCompsDistances","Infinity","eventFragmentIndex","closestEvents","distanceBetweenClosestEvents","splitAxisEventsByFragments","xEventsPartition","yEventsPartition","findBestPartition","strategies","isNewMergeFlow","bestPartition","handler","strategyName","bestPartitionY","bestPartitionX","findBestPartitionByStrategy","partitionX","partitionY","verticalWeight","bestDistancePartition","findBestDistancePartition","getSortedComponents","settings","detectSemanticGroups","useOverlapRules","overlayGroupId","getSortedOverlappingComponents","haveTransformedLayout","compsList","restoreLayouts","transformLayouts","eventsY","eventsX","orderedComps","getSortedOverlappingComponentsOld","enableNewMergeFlow","originalLayout","transformedLayout","recursive","setComponentsOrder","orderedComponents","splitToFragments","siblings","sweepSortAnalyzer","sortSiblings","rowsComponents","sortedComponents","rowComponents","columnsComponents","sortedColumnsComponents","columnComponents","getComponentsOrder","conversionUtils","sortedChildren","parentOrderMap","childrenOrderMaps"],"mappings":"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","file":"mobileLayoutUtils.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import * as _ from 'lodash';\nimport {conversionConfig} from './conversionConfig';\nimport {objectUtils} from 'santa-core-utils';\n\nexport const isMergeVirtualGroup = (comp): boolean => _.get(comp, 'componentType') === conversionConfig.VIRTUAL_GROUP_TYPES.MERGE;\nexport const isRescaleVirtualGroup = (comp): boolean => _.get(comp, 'componentType') === conversionConfig.VIRTUAL_GROUP_TYPES.RESCALE;\nexport const isVirtualGroup = (comp): boolean => isRescaleVirtualGroup(comp) || isMergeVirtualGroup(comp);\n\nexport function isDesktopOnlyComponent(component: ComponentWithConversionData): boolean {\n    return _.get(component, ['conversionData', 'desktopOnly'], false);\n}\n\nexport function isTextComponent(component: ComponentWithConversionData): boolean {\n    return _.get(component, ['conversionData', 'category']) === 'text';\n}\n\nexport function isVerticalText(component: ComponentWithConversionData) {\n    return _.get(component, ['conversionData', 'isVerticalText'], false);\n}\n\nexport function isGraphicComponent(component: ComponentWithConversionData): boolean {\n    return _.get(component, ['conversionData', 'category']) === 'graphic' || isImageComponent(component);\n}\n\nexport function isGroupComponent(component: Component): boolean {\n    return component && (component.componentType === 'wysiwyg.viewer.components.Group');\n}\n\nexport function isColumnsContainerComponent(component: ComponentWithConversionData): boolean {\n    return _.get(component, ['conversionData', 'category']) === 'columns';\n}\n\nexport function isImageComponent(component: ComponentWithConversionData): boolean {\n    return _.get(component, ['conversionData', 'category']) === 'photo';\n}\n\nexport function isMasterPage(component: Component | MasterPageComponent): component is MasterPageComponent {\n    return _.get(component, 'id') === 'masterPage';\n}\n\nexport function isMasterPageChild(component: Component): boolean {\n    return _.includes(['SITE_FOOTER', 'SITE_HEADER', 'SITE_PAGES', 'PAGES_CONTAINER'], component.id);\n}\n\nexport function isDockingAllowed(comp: Component | MasterPageComponent): boolean {\n    return _.get(comp, ['conversionData', 'isDockingAllowed']);\n}\n\nexport function isFixedPositionAllowed(comp: ComponentWithConversionData | MasterPageComponent): boolean {\n    return _.get(comp, ['conversionData', 'isFixedPositionAllowed']);\n}\n\nexport function isFixedPositionElement(comp: Component | MasterPageComponent): boolean {\n    return _.get(comp, [ 'layout', 'fixedPosition' ], false);\n}\n\nexport function shouldConvertFixedPositionToAbsolute(comp: ComponentWithConversionData | MasterPageComponent) {\n    return _.get(comp, [ 'conversionData', 'convertFixedPositionToAbsolute' ], false);\n}\n\nexport  function isExistsBeforeMerge(mobileComp: ComponentWithConversionData): boolean {\n    return mobileComp.existsBeforeMerge;\n}\n\nexport function shouldStretchToScreenWidth(component: ComponentWithConversionData): boolean {\n    const shouldStretchHorizontally = comp =>\n        _.get(comp.conversionData, 'isScreenWidth', false) ||\n        _.get(comp.conversionData, 'stretchHorizontally', false) ||\n        _.some(comp.components, shouldStretchHorizontally);\n\n    return isSiteSegmentOrPage(component) || shouldStretchHorizontally(component);\n}\n\nexport function extractComponentsFromStructureByType(root: Component | MasterPageComponent, compTypes: string[]) {\n    const children = getChildren(root);\n    const extractedChildrenByType = _.remove(children, child => _.includes(compTypes, child.componentType));\n    return _.concat(extractedChildrenByType, _.flatMap(children, extractComponentsFromStructureByType));\n}\n\nexport function isScreenWidthComponent(component: ComponentWithConversionData): boolean {\n    return _.get(component.conversionData, 'isScreenWidth', false) || _.some(component.components, isScreenWidthComponent);\n}\n\nexport function translateComps(comps: Component[], x: number = 0, y: number = 0): void {\n    _.forEach(comps, comp => {\n        comp.layout.x += x;\n        comp.layout.y += y;\n    });\n}\n\nexport function reparentComponent(parent: Component | MasterPageComponent, newChild: Component, index?: number): void {\n    addComponentsTo(parent, [newChild], index);\n    translateComps([newChild], -parent.layout.x, -parent.layout.y);\n}\n\nexport function addComponentsTo(container: Component | MasterPageComponent, components: Component[], index?: number): void {\n    const children = getChildren(container);\n\n    if (!components.length || !children) {\n        return;\n    }\n    index = index !== undefined ? index : children.length;\n    children.splice.apply(children, (<any[]> [index, 0]).concat(components));\n}\n\nexport function removeChildrenFrom(container: Component | MasterPageComponent, componentsToRemove: Component[]): void {\n    const children = getChildren(container);\n    _.remove(children, child => _.includes(componentsToRemove, child));\n}\n\nexport function removeGroup(group: Component, groupParent: Component) {\n    if (!isGroupComponent(group)) {\n        return;\n    }\n\n    const groupIndex = _.findIndex(groupParent.components, {id: group.id});\n\n    _.forEach(group.components.reverse(), (curGroupedComponent) => {\n        addComponentsTo(groupParent, [curGroupedComponent], groupIndex);\n        translateComps([curGroupedComponent], group.layout.x, group.layout.y);\n    });\n    _.remove(groupParent.components, group);\n}\n\nexport function containsComponent(container: ComponentWithConversionData, componentMatcher: (comp: ComponentWithConversionData) => boolean): boolean {\n    return _.some(getChildren(container), (child: ComponentWithConversionData) => componentMatcher(child) || child && containsComponent(child, componentMatcher));\n}\n\nexport function getHeightAccordingToChildren(container: ComponentWithConversionData, children?: ComponentWithConversionData[], enforceShrinkEvenWithNoChildren?: boolean): number|undefined {\n    if (isMasterPage(container)) {\n        return;\n    }\n\n    if (!children || (!enforceShrinkEvenWithNoChildren && _.isEmpty(children))) {\n        return;\n    }\n\n    const lowestChildBottom = <number> _(children)\n        .reject(['conversionData.isInvisible',  true])\n        .reduce((lowest, child) => _.max([lowest, child.layout.y + child.layout.height, 0]), 0);\n\n    if (_.get(container, ['conversionData', 'hasTightYMargin']) || _.get(container, ['conversionData', 'hasTightBottomMargin'])) {\n        return lowestChildBottom;\n    }\n\n    const bottomMargin = shouldStretchToScreenWidth(container) ? conversionConfig.SECTION_MOBILE_MARGIN_Y : conversionConfig.COMPONENT_MOBILE_MARGIN_Y + _.get(container.conversionData, 'borderWidth', 0);\n    return lowestChildBottom + bottomMargin;\n}\n\nexport function ensureContainerTightlyWrapsChildren(container: Component, children?: Component[], enforceShrinkEvenWithNoChildren?: boolean, defaultMinHeight: number = 0): void {\n    const heightByChildren = getHeightAccordingToChildren(<ComponentWithConversionData> container, <ComponentWithConversionData[]> children, enforceShrinkEvenWithNoChildren);\n    if (_.isNumber(heightByChildren)) {\n        const minHeight = _.get(container, ['conversionData', 'minHeight'], defaultMinHeight);\n        container.layout.height = Math.max(minHeight, heightByChildren);\n    }\n}\n\nexport function isSiteSegmentOrPage(component: ComponentWithConversionData): boolean {\n    return isPageComponent(component) || isSiteSegment(component);\n}\n\nexport function isPageComponent(component: Component): boolean {\n    return component.type === 'Page';\n}\n\nexport function isMobileOnlyElement(mobileComponent: ComponentWithConversionData): boolean {\n    return _.get(mobileComponent, ['conversionData', 'mobileHints', 'mobileOnlyElement']);\n}\n\nexport function isModifiedComponent(component: ComponentWithConversionData) {\n    return _.get(component, [ 'conversionData', 'mobileHints', 'modifiedByUser' ], false);\n}\n\nexport function isContainerComponent(component: Component): boolean {\n    return component.type === 'Container';\n}\n\nexport function isSiteSegment(component: ComponentWithConversionData): boolean {\n    return _.has(component.conversionData, 'siteSegmentRole');\n}\n\nexport function isAllowedToBeInMasterPage(component: ComponentWithConversionData): boolean {\n    return isSiteSegment(component) || _.has(component.conversionData, 'isAllowedToBeChildOfMasterPage');\n}\n\nexport function extractMobilePage(desktopPage: PageComponent | MasterPageComponent): PageComponent | MasterPageComponent {\n    const mobilePage = objectUtils.cloneDeep(desktopPage);\n    const childrenPropertyName = _.has(mobilePage, 'components') ? 'components' : 'children';\n    return <PageComponent | MasterPageComponent> _.set(mobilePage, childrenPropertyName, desktopPage.mobileComponents || []);\n}\n\nexport function getComponentByIdFromStructure(componentId: string, component: Component | MasterPageComponent): Component | MasterPageComponent | null {\n    if (component.id === componentId) {\n        return <Component> component;\n    }\n    let res = null;\n    _.find(getChildren(component), (comp) => {\n        res = getComponentByIdFromStructure(componentId, comp);\n        return res;\n    });\n    return res;\n}\n\nexport function unifyGroups(groups: string[][], groupOverflowThreshold?: number): void {\n    if (groups.length > groupOverflowThreshold) {\n        groups.length = 0;\n        return;\n    }\n    const haveCommonElements = (arr1, arr2) => _.size(_.intersection(arr1, arr2)) > 0;\n    for (let i = groups.length - 1; i >= 0; i--) {\n        const j = _.findLastIndex(groups, (group, index) => index < i && haveCommonElements(groups[i], group));\n        if (j !== -1) {\n            groups[j] = groups[j].concat(_.difference(groups[i], groups[j]));\n            groups.splice(i, 1);\n        }\n    }\n}\n\nexport function getComponentsByIds(container: Component | MasterPageComponent, compIds: string[]): Component[] {\n    const children = getChildren(container);\n    return _.map(compIds, id => _.find(children, {id}) || null);\n}\n\nexport function getParent(componentId: string, root: Component | MasterPageComponent): Component | MasterPageComponent | null {\n    const children = getChildren(root);\n    if (_.find(children, {id: componentId})) {\n        return root;\n    }\n    let parent = null;\n    _.find(children, child => {\n        parent = getParent(componentId, child);\n        return parent;\n    });\n    return parent;\n}\n\nexport function getSnugLayout(components: Component[]): Layout {\n    if (!components || components.length === 0) {\n        return undefined;\n    }\n    const mostLeft = <number> _.min(_.map(components, 'layout.x'));\n    const mostTop = <number> _.min(_.map(components, 'layout.y'));\n    const mostRight = _.max(_.map(components, c => c.layout.x + c.layout.width));\n    const mostBottom = _.max(_.map(components, c => c.layout.y + c.layout.height));\n    return {\n        x: mostLeft,\n        y: mostTop,\n        width: mostRight - mostLeft,\n        height: mostBottom - mostTop,\n        rotationInDegrees: 0\n    };\n}\n\nexport function getTinyMenuDefaultPosition(): { x: number; y: number; rotationInDegrees: number; } {\n    return {\n        x: conversionConfig.MOBILE_WIDTH - (conversionConfig.TINY_MENU_SIZE + conversionConfig.SITE_SEGMENT_PADDING_X),\n        y: conversionConfig.SECTION_MOBILE_MARGIN_Y,\n        rotationInDegrees: 0\n    };\n}\n\nexport function getChildren(comp: Component | PageComponent | MasterPageComponent): Component[] {\n    return (<Component> comp).components || (<MasterPageComponent> comp).children;\n}\n\nexport function getRangesOverlap(range1: number[] = [], range2: number[] = []) {\n    const getSortedRangesOverlap = (r1, r2) => Math.min(r1[1], r2[1]) - r2[0];\n    return range1[0] <= range2[0] ? getSortedRangesOverlap(range1, range2) : getSortedRangesOverlap(range2, range1);\n}\n\nexport function getYOverlap(comp1: Component, comp2: Component): number {\n    const getYProjection = (comp) => [comp.layout.y, comp.layout.height + comp.layout.y];\n    return getRangesOverlap(getYProjection(comp1), getYProjection(comp2));\n}\n\nexport function getXOverlap(comp1: ComponentWithConversionData, comp2: ComponentWithConversionData): number {\n    if (isScreenWidthComponent(comp1)) {\n        return comp2.layout.width;\n    }\n    if (isScreenWidthComponent(comp2)) {\n        return comp1.layout.width;\n    }\n    const getXProjection = (comp) => [comp.layout.x, comp.layout.width + comp.layout.x];\n    return getRangesOverlap(getXProjection(comp1), getXProjection(comp2));\n}\n\nconst getArea = (component: Component) => component.layout.width * component.layout.height;\n\nexport function hasGreaterArea(comp1, comp2) {\n    if (isScreenWidthComponent(comp1)) {\n        return comp1.layout.height >= comp2.layout.height || getArea(comp1) > getArea(comp2);\n    }\n    if (isScreenWidthComponent(comp2)) {\n        return false;\n    }\n    return getArea(comp1) > getArea(comp2);\n}\n\nexport function haveSufficientOverlap(comp1: ComponentWithConversionData, comp2: ComponentWithConversionData, overlapToMinAreaRationThreshold?): boolean {\n    const xOverlap = getXOverlap(comp1, comp2);\n    const yOverlap = getYOverlap(comp1, comp2);\n    if (xOverlap <= 0 || yOverlap <= 0) {\n        return false;\n    }\n    const overlapArea = xOverlap * yOverlap;\n    const minCompArea = Math.min(getArea(comp1), getArea(comp2));\n    return overlapArea > 0 && overlapArea / minCompArea >= overlapToMinAreaRationThreshold;\n}\n\nexport function isEmptyContainer(component: ComponentWithConversionData): boolean {\n    if (!isContainerComponent(component)) {\n        return false;\n    }\n    if (component.conversionData.category === 'columns') {\n        return _.size(component.components) === 1 && _.isEmpty(component.components[0].components);\n    }\n    return _.isEmpty(component.components);\n}\n\nexport function shouldReparentCompToChildOfContainer(comp, container): boolean {\n    return isColumnsContainerComponent(container) && _.get(comp, ['conversionData', 'isInvisible'], false);\n}\n\nexport function getAllCompsInStructure(compStructure: Component | MasterPageComponent, isMobile: boolean = false, filterFunc?: (comp: Component | MasterPageComponent) => boolean): ObjMap<Component> {\n    const queue = [[compStructure]];\n    for (const innerQueue of queue) {\n        _.forEach(innerQueue, child => {\n            const children = isMobile ? _.get(child, 'mobileComponents') : getChildren(child);\n            if (!_.isEmpty(children)) {\n                queue.push(<Component[]> children);\n            }\n        });\n    }\n\n    return <ObjMap<Component>> _(queue).flatten().remove(filterFunc).keyBy('id').value();\n}\n","export const conversionConfig = {\n    MOBILE_WIDTH: 320,\n    MARGIN_BETWEEN_TEXT_AND_NON_TEXT: 20,\n    COMPONENT_MOBILE_MARGIN_X: 10,\n    COMPONENT_MOBILE_MARGIN_Y: 10,\n    SECTION_MOBILE_MARGIN_Y: 20,\n    SITE_SEGMENT_PADDING_X: 20,\n    TINY_MENU_SIZE: 50,\n    TEXT_MAX_LENGTH_FOR_RESCALING: 25,\n    MIN_WIDTH_FOR_ENLARGE: 140,\n    DEFAULT_TEXT_HEIGHT: 10,\n\n    VIRTUAL_GROUP_TYPES: {\n        RESCALE: 'RESCALE_VIRTUAL_GROUP',\n        MERGE: 'MERGE_VIRTUAL_GROUP'\n    }\n};\n","import * as _ from 'lodash';\nimport * as conversionUtils from '../conversionUtils';\n\nconst EQUALITY_DEVIATION_THRESHOLD = 0.1;\n\nexport const getSign = (n: number): number => n === 0 ? 0 : n / Math.abs(n);\nexport const getComponentSize = (comp: ComponentWithConversionData, dim: Axis): number => dim === 'x' ? comp.layout.width : comp.layout.height;\nexport const getComponentEndCoordinate = (comp: ComponentWithConversionData, axis: Axis): number => comp.layout[axis] + getComponentSize(comp, axis);\nexport const compareComponentsByY = (c1: ComponentWithConversionData, c2: ComponentWithConversionData): number => getSign(c1.layout.y - c2.layout.y);\n\nfunction haveSimilarCoordinates(comp1: ComponentWithConversionData, comp2: ComponentWithConversionData, dim: Axis, deviationThreshold: number = EQUALITY_DEVIATION_THRESHOLD): boolean {\n    const v1 = <number> _.get(comp1, ['layout', dim]);\n    const v2 = <number> _.get(comp2, ['layout', dim]);\n    return Math.abs(v1 - v2) <= deviationThreshold * _.min([getComponentSize(comp1, dim), getComponentSize(comp2, dim)]);\n}\n\nfunction similarBy(comp1: ComponentWithConversionData, comp2: ComponentWithConversionData, valuePath: string[], deviationThreshold: number = EQUALITY_DEVIATION_THRESHOLD): boolean {\n    const v1 = <number> _.get(comp1, valuePath);\n    const v2 = <number> _.get(comp2, valuePath);\n    return Math.abs(v1 - v2) <= deviationThreshold * _.min([v1, v2]);\n}\n\nexport function areSimilarFragments(fragment1: ComponentWithConversionData[], fragment2: ComponentWithConversionData[], dimension: Axis): boolean {\n    if (fragment1 === fragment2) {\n        return true;\n    }\n    if (_.size(fragment1) !== _.size(fragment2) || shouldBreakFragment(fragment1, dimension) || shouldBreakFragment(fragment2, dimension)) {\n        return false;\n    }\n    return _.every(fragment1, (comp1, compIndex) => {\n        const comp2 = fragment2[compIndex];\n        return comp1.componentType === comp2.componentType && haveSimilarCoordinates(comp1, comp2, dimension) &&\n            (comp1.conversionData.category === 'text' ? similarBy(comp1, comp2, ['conversionData', 'averageNormalizedFontSize']) :\n            similarBy(comp1, comp2, ['layout', 'height']) && similarBy(comp1, comp2, ['layout', 'width']));\n    });\n}\n\nfunction shouldBreakFragment(fragment: ComponentWithConversionData[], dimension: Axis): boolean {\n    const firstDistantCompIndex = _.findIndex(fragment, (comp, compIndex) => {\n        if (compIndex === 0) {\n            return false;\n        }\n        const previousCompEnd = getComponentEndCoordinate(fragment[compIndex - 1], dimension);\n        const distance = comp.layout[dimension] - previousCompEnd;\n        return distance < 0 || distance > _.min([getComponentSize(fragment[compIndex - 1], dimension), getComponentSize(comp, dimension)]);\n    });\n    return firstDistantCompIndex !== -1 && firstDistantCompIndex !== fragment.length - 1;\n}\n\nexport function getOrderedComponents(parent: ComponentWithConversionData | MasterPageComponentWithConversionData): ComponentWithConversionData[] {\n    const children = conversionUtils.getChildren(parent);\n    return <ComponentWithConversionData[]> _.map(parent.conversionData.componentsOrder, id => _.find(children, {id}));\n}\n\nexport const shouldUseNaturalOrder = (comp: ComponentWithConversionData | MasterPageComponentWithConversionData) =>\n    conversionUtils.isRescaleVirtualGroup(comp) && comp.conversionData.rescaleMethod !== 'reorder' ||\n    comp.conversionData.structuralContainer;\n\nexport function sortComponentsByNaturalOrder(parent: MasterPageComponentWithConversionData | ComponentWithConversionData, comps: ComponentWithConversionData[]): ComponentWithConversionData[] {\n    const childrenIds = _.map(conversionUtils.getChildren(parent), 'id');\n    return _.sortBy(comps, comp => childrenIds.indexOf(comp.id));\n}\n\nexport function hasMobileHintsPresets(comp: ComponentWithConversionData | MasterPageComponentWithConversionData): boolean {\n    const mobileHints = _.pick(comp.conversionData.mobileHints, ['recommendedWidth', 'recommendedHeight', 'recommendedScale', 'recommendedOrder']);\n    return !_.isEmpty(mobileHints);\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","\nimport * as _ from 'lodash';\nimport {getSign, getComponentEndCoordinate, areSimilarFragments, sortComponentsByNaturalOrder, getComponentSize} from './analyzerUtils';\nimport {objectUtils} from 'santa-core-utils';\n\nconst EVENTS_TYPES = {\n    START_EVENT: 'start',\n    END_EVENT: 'end'\n};\n\nconst COMPONENT_SIZE_SCALE_FACTOR = 0.9;\n\nconst DISTANCE_PARTITIONS_WEIGHTS = {\n    HORIZONTAL: 1,\n    VERTICAL: 1.25\n};\n\ninterface PartitionsStrategies {\n    singleCompRow: boolean;\n    verticalDivider: boolean;\n    mirrorPattern: boolean;\n    chessPattern: boolean;\n}\n\ntype StrategyHandler = (fragments: Fragment[], allEvents: {x: Event[]; y: Event[]; }, partitionAxis: Axis) => Partition | null;\n\nfunction findVerticalDividerFragmentIndex(fragments: Fragment[], allEvents: {x: Event[]; y: Event[]; }): number {\n    const eventsCoordinates = <number[][]> _(allEvents.y).partition({eventType: EVENTS_TYPES.START_EVENT}).map(a => _.map(a, 'coordinate')).value();\n    const maxStart = _.max(eventsCoordinates[0]);\n    const minEnd = _.min(eventsCoordinates[1]);\n    return _.findIndex(fragments, fragment => {\n        const firstComp = fragment.comps[0];\n        return fragment.comps.length === 1 && firstComp.conversionData.keepIfVerticalDivider &&\n            firstComp.layout.y <= minEnd && getComponentEndCoordinate(firstComp, 'y') >= maxStart;\n    });\n}\n\nfunction refragment(fragments: Fragment[], getNewFragmentIndex: (originalIndex: number) => number): Fragment[] {\n    return _.transform(fragments, (res, fragment, fragmentIndex) => {\n        const newFragmentIndex = getNewFragmentIndex(fragmentIndex);\n        res[newFragmentIndex] = res[newFragmentIndex] || {comps: [], distanceToPreviousFragment: fragment.distanceToPreviousFragment};\n        res[newFragmentIndex].comps = [...res[newFragmentIndex].comps, ...fragment.comps];\n        return res;\n    }, []);\n}\n\nconst strategiesHandlers = {\n    singleCompRow(fragments: Fragment[], allEvents: {x: Event[]; y: Event[]; }, partitionAxis: Axis) {\n        if (partitionAxis === 'x') {\n            return null;\n        }\n        const singleCompRowIndex = _.findIndex(fragments, fragment => _.size(fragment.comps) === 1);\n        if (singleCompRowIndex === -1) {\n            return null;\n        }\n        const getNewFragmentIndex = (oldFragmentIndex: number) => getSign(oldFragmentIndex - singleCompRowIndex) + getSign(singleCompRowIndex);\n        const newFragments = refragment(fragments, getNewFragmentIndex);\n        return <Partition> {type: 'singleCompRow', fragments: newFragments, fragmentsEvents: splitAllEventsByFragments(allEvents, newFragments)};\n    },\n\n    verticalDivider(fragments: Fragment[], allEvents: {x: Event[]; y: Event[]; }, partitionAxis: Axis): Partition | null {\n        const isSingleCompFragment = (fragment) => _.size(fragment.comps) === 1;\n        if (_.size(fragments) < 3 || _.every(fragments, isSingleCompFragment) || partitionAxis === 'y') {\n            return null;\n        }\n        const dividerFragmentIndex = findVerticalDividerFragmentIndex(fragments, allEvents);\n        if (dividerFragmentIndex === -1) {\n            return null;\n        }\n        _.set(fragments[dividerFragmentIndex].comps[0], ['conversionData', 'isVerticalDivider'], true);\n        const getNewFragmentIndex = (oldFragmentIndex: number) => getSign(oldFragmentIndex - dividerFragmentIndex) + getSign(dividerFragmentIndex);\n        const newFragments = refragment(fragments, getNewFragmentIndex);\n        return <Partition> {type: 'verticalDivider', fragments: newFragments, fragmentsEvents: splitAllEventsByFragments(allEvents, newFragments)};\n    },\n\n    mirrorPattern(fragments: Fragment[], allEvents: {x: Event[]; y: Event[]; }, partitionAxis: Axis): Partition | null {\n        if (_.size(fragments) < 2) {\n            return null;\n        }\n        const fragmentsEvents = splitAllEventsByFragments(allEvents, fragments);\n        const perpAxis = getPerpendicularAxis(partitionAxis);\n        const sortedFragmentsComps = <ComponentWithConversionData[][]> _.map(fragmentsEvents, fragmentEvents => extractCompsFromEvents(fragmentEvents[perpAxis]));\n        const isMirrorPattern = _.every(sortedFragmentsComps, fragmentComps => areSimilarFragments(fragmentComps, sortedFragmentsComps[0], perpAxis));\n        if (!isMirrorPattern) {\n            return null;\n        }\n        return isMirrorPattern ? createSingleFragmentPartition(_.flatten(sortedFragmentsComps), allEvents, {type: 'mirrorPattern'}) : null;\n    },\n\n    chessPattern(fragments: Fragment[], allEvents: {x: Event[]; y: Event[]; }, partitionAxis: Axis): Partition | null {\n        const isValidFragmentSize = (fragment) => _.size(fragment.comps) === 2;\n        if (partitionAxis !== 'y' || _.size(fragments) < 2 || !_.every(fragments, isValidFragmentSize)) {\n            return null;\n        }\n        const fragmentsEvents = splitAllEventsByFragments(allEvents, fragments);\n        const xSortedFragmentsComps = <ComponentWithConversionData[][]> _.map(fragmentsEvents, fragmentEvents => extractCompsFromEvents(fragmentEvents.x));\n        const chessSortedComps = _.flatMap(xSortedFragmentsComps, (fragmentComps, fragmentIndex) => isEven(fragmentIndex) ? fragmentComps : _.reverse(fragmentComps));\n        const evenCategory = chessSortedComps[0].conversionData.category;\n        const oddCategory = evenCategory === 'text' ? 'photo' : 'text';\n        const isValidChessComp = (comp, compIndex) => comp.conversionData.category === (isEven(compIndex) ? evenCategory : oddCategory);\n        const isChessPattern = _.every(chessSortedComps, isValidChessComp);\n        return isChessPattern ? createSingleFragmentPartition(<ComponentWithConversionData[]> chessSortedComps, allEvents, {type: 'chessPattern'}) : null;\n    }\n};\n\ninterface DistancePartition extends Partition {\n    maxCompsDistance: number;\n}\n\nexport const extractCompsFromEvents = (events: Event[]): ComponentWithConversionData[] => <ComponentWithConversionData[]> _(events).map('compRef').uniq().value();\nconst getPerpendicularAxis = (axis: Axis): Axis => axis === 'x' ? 'y' : 'x';\nconst isEven = (n: number): boolean => n % 2 === 0;\n\nfunction createSingleFragmentPartition(sortedComps: ComponentWithConversionData[], allEvents: {x: Event[]; y: Event[]; }, partitionData: {type: string}): Partition {\n    return <Partition> _.assign(partitionData, {fragments: [{comps: sortedComps, distanceToPreviousFragment: -1}], fragmentsEvents: [allEvents]});\n}\n\nfunction compareEvents(event1: Event, event2: Event): number {\n    const distance = event1.coordinate - event2.coordinate;\n    if (distance !== 0) {\n        return getSign(distance);\n    }\n    if (event1.compRef === event2.compRef) {\n        return event1.eventType === EVENTS_TYPES.END_EVENT ? 1 : -1;\n    }\n    return event1.eventType === EVENTS_TYPES.END_EVENT ? -1 : 1;\n}\n\nfunction insertStable(arr: Event[], event: Event): Event[] {\n    const i = _.findLastIndex(arr, e => {\n        if (e.coordinate === event.coordinate) {\n            if (e.eventType === EVENTS_TYPES.START_EVENT && event.eventType === EVENTS_TYPES.START_EVENT) {\n                return e.size > event.size;\n            }\n            if (e.eventType === EVENTS_TYPES.END_EVENT && event.eventType === EVENTS_TYPES.END_EVENT) {\n                return e.size < event.size;\n            }\n            if (e.eventType === EVENTS_TYPES.START_EVENT && event.eventType === EVENTS_TYPES.END_EVENT) {\n                return e.compRef === event.compRef;\n            }\n            if (e.eventType === EVENTS_TYPES.END_EVENT && event.eventType === EVENTS_TYPES.START_EVENT) {\n                return e.compRef !== event.compRef;\n            }\n        }\n        return e.coordinate < event.coordinate;\n    });\n    arr.splice(i + 1, 0, event);\n    return arr;\n}\n\nexport function createEventsQueue(comps: ComponentWithConversionData[], axis: Axis): Event[] {\n    const events = _.transform(comps, (eventsQueue, comp: ComponentWithConversionData) => {\n        const componentStartPosition = comp.layout[axis] || 0;\n        const componentEndPosition = getComponentEndCoordinate(comp, axis) || componentStartPosition;\n        const componentSize = getComponentSize(comp, axis) || 0;\n        insertStable(eventsQueue, <Event> {eventType: EVENTS_TYPES.START_EVENT, compRef: comp, coordinate: componentStartPosition, size: componentSize});\n        insertStable(eventsQueue, <Event> {eventType: EVENTS_TYPES.END_EVENT, compRef: comp, coordinate: componentEndPosition, size: componentSize});\n        return eventsQueue;\n    }, []);\n    return _.map(events, event => <Event> _.omit(event, 'size'));\n}\n\nexport function createFragments(sweepLineEvents: Event[]): Fragment[] {\n    const sweepLineStatus: Event[] = [];\n    const fragments = [];\n\n    _.forEach(sweepLineEvents, (event: Event) => {\n        const lastFragment = <{events: Event[]; distanceToPreviousFragment: number; }> _.last(fragments);\n        if (event.eventType === EVENTS_TYPES.START_EVENT) {\n            if (_.isEmpty(sweepLineStatus)) {\n                const distance = lastFragment ? event.coordinate - _.last(lastFragment.events).coordinate : -1;\n                const newFragment = {events: [event], distanceToPreviousFragment: distance};\n                fragments.push(newFragment);\n            } else {\n                lastFragment.events.push(event);\n            }\n            sweepLineStatus.push(event);\n        } else {\n            _.remove(sweepLineStatus, {compRef: event.compRef});\n            lastFragment.events.push(event);\n        }\n    });\n\n    return <Fragment[]> _.map(fragments, group => {\n        return {comps: extractCompsFromEvents(group.events), distanceToPreviousFragment: group.distanceToPreviousFragment};\n    });\n}\n\nfunction divideByDistance(fragments: Fragment[], allEvents: {x: Event[]; y: Event[]; }, partitionAxis: Axis): DistancePartition {\n    const mostDistantFragment = _.maxBy(fragments, 'distanceToPreviousFragment');\n    const mostDistantFragmentIndex = _.findIndex(fragments, mostDistantFragment);\n    const getNewFragmentIndex = (oldFragmentIndex: number) => oldFragmentIndex < mostDistantFragmentIndex ? 0 : 1;\n    const newFragments = refragment(fragments, getNewFragmentIndex);\n    const adjacentFragments = [fragments[mostDistantFragmentIndex - 1], mostDistantFragment];\n    const adjacentFragmentsEvents = _.filter(allEvents[getPerpendicularAxis(partitionAxis)], (e: Event) => _.some(adjacentFragments, g => _.includes(g.comps, e.compRef)));\n    const partition = {fragmentsEvents: splitAllEventsByFragments(allEvents, newFragments), fragments: newFragments};\n    const maxCompsDistance = calculateMaxCompsDistance(adjacentFragments, adjacentFragmentsEvents, partitionAxis);\n    return <DistancePartition> _.assign(partition, {maxCompsDistance});\n}\n\nfunction extractPartitionAxisVectors(eventsPartition: Event[][], axis: Axis): PartitionAxisVectorEvent[][] {\n    return _(eventsPartition)\n        .map((events: Event[], vectorIndex) => {\n            return <PartitionAxisVectorEvent[]> (vectorIndex ?\n                _.map(events, (e: Event) => _.defaults({closestPoint: e.compRef.layout[axis]}, e)) :\n                _.map(events, (e: Event) => _.defaults({closestPoint: getComponentEndCoordinate(e.compRef, axis)}, e)));\n            })\n        .map((events: PartitionAxisVectorEvent[], vectorIndex) => {\n            return _.reduce(events, (vector, e) => {\n                const lastAddedEvent = _.last(vector);\n                if (!lastAddedEvent || lastAddedEvent.eventType === EVENTS_TYPES.END_EVENT) {\n                    return vector.concat(e.eventType === EVENTS_TYPES.START_EVENT ? [e] : []);\n                }\n                if (lastAddedEvent.compRef === e.compRef) {\n                    return [...vector, e];\n                }\n                if (vectorIndex && e.closestPoint < lastAddedEvent.closestPoint || !vectorIndex && e.closestPoint > lastAddedEvent.closestPoint) {\n                    vector.splice(vector.length - 1, 1, e);\n                }\n                return vector;\n            }, []);\n        })\n        .value();\n}\n\ninterface PartitionAxisVectorEvent extends Event {\n    closestPoint: number;\n}\n\nfunction calculateMaxCompsDistance(fragments: Fragment[], fragmentsEvents: Event[], axis: Axis): number {\n    const eventsPartition = _.partition(fragmentsEvents, e => _.includes(fragments[0].comps, e.compRef));\n    const events = extractPartitionAxisVectors(eventsPartition, axis);\n    const eventIndex = [0, 0];\n    const sweepLineStatus: PartitionAxisVectorEvent[][] = [[], []];\n\n    function getNextEventFragmentIndex() {\n        if (eventIndex[0] === events[0].length || eventIndex[1] === events[1].length) {\n            return eventIndex[0] === events[0].length ? 1 : 0;\n        }\n        return events[0][eventIndex[0]].coordinate <= events[1][eventIndex[1]].coordinate ? 0 : 1;\n    }\n    let maxCompsDistances = -Infinity;\n    while (eventIndex[0] < events[0].length || eventIndex[1] < events[1].length) {\n        const eventFragmentIndex = getNextEventFragmentIndex();\n        const event = events[eventFragmentIndex][eventIndex[eventFragmentIndex]++];\n        if (event.eventType === EVENTS_TYPES.END_EVENT) {\n            _.remove(sweepLineStatus[eventFragmentIndex], {compRef: event.compRef});\n            continue;\n        }\n        sweepLineStatus[eventFragmentIndex].push(event);\n        const closestEvents = [_.maxBy(sweepLineStatus[0], 'closestPoint'), _.minBy(sweepLineStatus[1], 'closestPoint')];\n        const distanceBetweenClosestEvents = <number> _.get(closestEvents, [1, 'closestPoint']) - <number> _.get(closestEvents, [0, 'closestPoint']);\n        if (!_.isNaN(distanceBetweenClosestEvents) && distanceBetweenClosestEvents > maxCompsDistances) {\n            maxCompsDistances = distanceBetweenClosestEvents;\n        }\n    }\n    return maxCompsDistances;\n}\n\nexport function splitAxisEventsByFragments(events: Event[], fragments: Fragment[]): Event[][] {\n    return _.transform(events, (res, event) => {\n        const eventFragmentIndex = _.findIndex(fragments, group => _.includes(group.comps, event.compRef));\n        res[eventFragmentIndex] = [...(res[eventFragmentIndex] || []), event];\n        return res;\n    }, []);\n}\n\nfunction splitAllEventsByFragments(allEvents: {x: Event[]; y: Event[]; }, fragments: Fragment[]): Array<{x: Event[]; y: Event[]; }> {\n    const xEventsPartition = splitAxisEventsByFragments(allEvents.x, fragments);\n    const yEventsPartition = splitAxisEventsByFragments(allEvents.y, fragments);\n    return <Array<{x: Event[]; y: Event[]; }>> _.map(_.keys(fragments), index => _.assign({}, {x: xEventsPartition[index], y: yEventsPartition[index]}));\n}\n\nfunction findBestPartitionByStrategy(allEvents: {x: Event[]; y: Event[]; }, fragments: {x: Fragment[]; y: Fragment[]; }, strategies: PartitionsStrategies): Partition | null {\n    let bestPartition = null;\n    _.forEach(strategiesHandlers, (handler: StrategyHandler, strategyName) => {\n        if (!strategies[strategyName]) {\n            return true;\n        }\n        const bestPartitionY =  handler(fragments.y, allEvents, 'y');\n        const bestPartitionX =  handler(fragments.x, allEvents, 'x');\n        bestPartition = bestPartitionY && bestPartitionX ? null : bestPartitionY || bestPartitionX;\n        return bestPartition === null;\n    });\n    return bestPartition;\n}\n\nfunction findBestDistancePartition(allEvents: {x: Event[]; y: Event[]; }, fragments: {x: Fragment[]; y: Fragment[]; }, isNewMergeFlow = false): Partition {\n    const partitionX = _.size(fragments.x) > 1 ? divideByDistance(fragments.x, allEvents, 'x') : null;\n    const partitionY = _.size(fragments.y) > 1 ? divideByDistance(fragments.y, allEvents, 'y') : null;\n    if (partitionX && partitionY) {\n        const verticalWeight = isNewMergeFlow ? 3.27 : DISTANCE_PARTITIONS_WEIGHTS.VERTICAL;\n        const bestDistancePartition = DISTANCE_PARTITIONS_WEIGHTS.HORIZONTAL * partitionX.maxCompsDistance > verticalWeight * partitionY.maxCompsDistance ? partitionX : partitionY;\n        return <Partition> _.pick(bestDistancePartition, ['fragments', 'fragmentsEvents']);\n    }\n    return partitionX || partitionY;\n}\n\nfunction findBestPartition(allEvents: {x: Event[]; y: Event[]; }, fragments: {x: Fragment[]; y: Fragment[]; }, strategies: PartitionsStrategies, isNewMergeFlow): Partition {\n    return findBestPartitionByStrategy(allEvents, fragments, strategies) || findBestDistancePartition(allEvents, fragments, isNewMergeFlow);\n}\n\nfunction getSortedOverlappingComponents(parent: ComponentWithConversionData | MasterPageComponentWithConversionData, comps: ComponentWithConversionData[]): ComponentWithConversionData[] {\n    comps = sortComponentsByNaturalOrder(parent, comps);\n    comps = _.sortBy(comps, 'layout.y');\n    const overlayGroupId = `overlayGroup_${comps[0].id}`;\n    _.forEach(comps, comp => _.set(comp, ['conversionData', 'overlayGroupId'], overlayGroupId));\n    return comps;\n}\n\nfunction getSortedComponents(parent: ComponentWithConversionData | MasterPageComponentWithConversionData, comps: ComponentWithConversionData[], allEvents: {x: Event[]; y: Event[]}, settings: ConversionSettings): ComponentWithConversionData[] {\n    if (_.size(comps) < 2) {\n        return comps || [];\n    }\n    const fragments = <{x: Fragment[]; y: Fragment[]; }> _.mapValues(allEvents, createFragments);\n    if (_.size(fragments.x) === 1 && _.size(fragments.y) === 1) {\n        if (!settings.detectSemanticGroups) {\n            return sortComponentsByNaturalOrder(parent, comps);\n        } else if (settings.useOverlapRules) {\n            return getSortedOverlappingComponents(parent, comps);\n        } else {\n            return getSortedOverlappingComponentsOld(parent, comps, settings);\n        }\n    }\n    const strategies = {\n        mirrorPattern: settings.detectSemanticGroups,\n        chessPattern: settings.detectSemanticGroups,\n        verticalDivider: true,\n        singleCompRow: true\n    };\n    const partition = findBestPartition(allEvents, fragments, strategies, settings.enableNewMergeFlow);\n    return _.size(partition.fragments) === 1 ? partition.fragments[0].comps :\n        _.flatMap(partition.fragments, (fragment, fragmentIndex) => getSortedComponents(parent, fragment.comps, partition.fragmentsEvents[fragmentIndex], settings));\n}\n\nfunction getSortedOverlappingComponentsOld(parent: ComponentWithConversionData | MasterPageComponentWithConversionData, comps: ComponentWithConversionData[], settings: ConversionSettings): ComponentWithConversionData[] {\n    const haveTransformedLayout = (compsList) => _.some(compsList, 'conversionData.originalLayout');\n    const isLayoutTransformed = haveTransformedLayout(comps) || _.some(comps, child => haveTransformedLayout(child));\n    if (isLayoutTransformed) {\n        restoreLayouts(comps);\n        return comps;\n    }\n    transformLayouts(comps);\n    const eventsY: Event[] = createEventsQueue(comps, 'y');\n    const eventsX: Event[] = createEventsQueue(comps, 'x');\n    const orderedComps = getSortedComponents(parent, comps, {y: eventsY, x: eventsX}, settings);\n    restoreLayouts(orderedComps);\n    return orderedComps;\n}\n\nfunction transformLayouts(comps: ComponentWithConversionData[]): void {\n    _.forEach(comps, comp => {\n        const originalLayout = comp.layout;\n        const transformedLayout = <Layout> _.assign(objectUtils.cloneDeep(originalLayout), {\n            height: originalLayout.height * COMPONENT_SIZE_SCALE_FACTOR,\n            width: originalLayout.width * COMPONENT_SIZE_SCALE_FACTOR\n        });\n        comp.layout = transformedLayout;\n        _.set(comp, ['conversionData', 'originalLayout'], originalLayout);\n    });\n}\n\nfunction restoreLayouts(comps: ComponentWithConversionData[], recursive: boolean = true): void {\n    _.forEach(comps, comp => {\n        const originalLayout = _.get(comp, ['conversionData', 'originalLayout']);\n        if (originalLayout) {\n            comp.layout = <Layout> objectUtils.cloneDeep(originalLayout);\n            delete (<any> comp).conversionData.originalLayout;\n        }\n    });\n    if (recursive) {\n        _.forEach(comps, comp => restoreLayouts(<ComponentWithConversionData[]> comp.components, false));\n    }\n}\n\nexport function setComponentsOrder(parent: ComponentWithConversionData | MasterPageComponentWithConversionData, comps: ComponentWithConversionData[], settings: ConversionSettings): void {\n    const eventsY: Event[] = createEventsQueue(comps, 'y');\n    const eventsX: Event[] = createEventsQueue(comps, 'x');\n    const orderedComponents = getSortedComponents(parent, comps, {y: eventsY, x: eventsX}, settings);\n    parent.conversionData.componentsOrder = <string[]> _.map(orderedComponents, 'id');\n}\n\nexport const testAPI = {\n    isEven,\n    transformLayouts,\n    restoreLayouts,\n    extractCompsFromEvents,\n    getPerpendicularAxis,\n    compareEvents,\n    refragment,\n    splitAxisEventsByFragments,\n    splitAllEventsByFragments,\n    calculateMaxCompsDistance,\n    sortComponentsByNaturalOrder\n};\n","import * as _ from 'lodash';\nimport * as sweepSortAnalyzer from '../mobileCore/analyzer/sweepSortAnalyzer';\nimport * as conversionUtils from '../mobileCore/conversionUtils';\n\nexport function splitToFragments(siblings, axis: Axis): Fragment[] {\n    const sweepLineEvents = sweepSortAnalyzer.createEventsQueue(siblings, axis);\n    return sweepSortAnalyzer.createFragments(sweepLineEvents);\n}\n\nexport function sortSiblings(components: Component[]): Component[] {\n    if (_.size(components) <= 1) {\n        return components;\n    }\n    const rowsComponents = _.map(splitToFragments(components, 'y'), 'comps');\n    return <Component[]> _.reduce(rowsComponents, (sortedComponents, rowComponents: Component[]) => {\n        if (_.size(rowComponents) === 1) {\n            return sortedComponents.concat(rowComponents);\n        }\n        const columnsComponents = _.map(splitToFragments(rowComponents, 'x'), 'comps');\n        const sortedColumnsComponents = <Component[]> _.flatMap(columnsComponents, (columnComponents: Component[]) => {\n            return _.size(columnComponents) === 1 ? columnComponents : _.sortBy(columnComponents, _.findIndex.bind(null, components));\n        });\n        return sortedComponents.concat(sortedColumnsComponents);\n    }, []);\n}\n\nexport function getComponentsOrder(parent: PageComponent | MasterPageComponent): ObjMap<string[]> {\n    const children = conversionUtils.getChildren(parent);\n    if (!children) {\n        return {};\n    }\n    const sortedChildren = sortSiblings(children);\n    const parentOrderMap = _.set({}, parent.id, _.map(sortedChildren, 'id'));\n    const childrenOrderMaps = _.map(children, getComponentsOrder);\n    return <ObjMap<string[]>> _.assign.apply(_, [parentOrderMap].concat(childrenOrderMaps));\n}\n"],"sourceRoot":""}
